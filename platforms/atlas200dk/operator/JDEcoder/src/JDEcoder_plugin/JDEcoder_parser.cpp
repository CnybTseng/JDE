/*
* Copyright (c) Huawei Technologies Co., Ltd. 2017-2018. All rights reserved.
* Description: generated by MindStudio
* Author: Huawei
* Create: 2017-06-06
*/
#include "custom/custom_op.h"
#include "framework/omg/register.h"
#include "framework/omg/omg_types.h"
#include "proto/caffe/caffe.pb.h"
#include "operator.h"
#include "attr_value.h"
#include <memory>
#include <string>
#include <vector>

namespace domi
{
    // Parse the parameters from caffe model, and pass them to the inner model.
    Status JDEcoderParseParams(const Message* op_origin, ge::Operator& op_dest)
    {
        const caffe::LayerParameter* layer = dynamic_cast<const caffe::LayerParameter*>(op_origin);

        // Ckeck operator parameter's validity
        if (nullptr == layer)
        {
            printf("Dynamic cast op_src to LayerParameter failed\n");
            return FAILED;
        }
        return SUCCESS;
    }

    // Function to acquire output tensor descriptor
    Status JDEcoderInferShapeAndType(const ge::Operator& op, vector<ge::TensorDesc>& v_output_desc)
    {
      auto tensorDesc      = op.GetInputDesc(0);
      auto shape = tensorDesc.GetShape();
      int64_t axis = -1;
        ge::AttrValue axisAttrValue;
        if ((ge::GRAPH_SUCCESS != op.GetAttr("axis", axisAttrValue)) || (ge::GRAPH_SUCCESS != axisAttrValue.GetValue<ge::AttrValue::INT>(axis)))
        {
            printf("Get axis failed!\n");
        }
        // In the OM model, all shape are supplemented to 4d. In this case, axis needs to be repaired to point to the original 2d.
        if (axis < 0) axis -= 2;

        if (axis < 0) axis += shape.GetDimNum();

        if (axis < 0 || axis >= shape.GetDimNum())
        {
            printf("invalid axis:%d, dim_size:%d\n", (int32_t)axis, (int32_t)shape.GetDimNum());
            return PARAM_INVALID;
        }
        int32_t dimsize = (int32_t)shape.GetDimNum();
        int32_t idx = 0;
        for(idx=axis; idx<dimsize; idx++)
        {
            shape.SetDim(idx, 1);
        }
        tensorDesc.SetShape(shape);
        v_output_desc.push_back(tensorDesc);

        return SUCCESS;
    }

    // Pass the parameters you just parsed from the parseParam() to the op python function
    Status JDEcoderBuildTeBin(const ge::Operator& op, TEBinInfo& te_bin_info)
    {
        std::string FilePath   = "";
        std::string FuncName   = "";
        std::string KernelName = "";

        // Parse operator's parameter and attach exception catching
        // Parse input tensor descriptor
        ge::TensorDesc input_desc = op.GetInputDesc(0);

        // Parse input shape, validate if it is equal to 4
        if (input_desc.GetShape().GetDimNum() != 4)
        {
            printf("The shape size is %d, which is not 4!", (int32_t)input_desc.GetShape().GetDimNum());
            return FAILED;
        }

        FilePath   = "/home/tseng/atlas200dk/projects/JDEcoder/JDEcoder/src/operator/JDEcoder";
        FuncName   = "JDEcoder";
        KernelName = "JDEcoder";

        bool buildResult = te::BuildTeCustomOp(te_bin_info.ddk_version, op.GetName(), FilePath, FuncName,
                "(i,i,i,i), s, s",
                input_desc.GetShape().GetDim(0), input_desc.GetShape().GetDim(1),
                input_desc.GetShape().GetDim(2), input_desc.GetShape().GetDim(3),
                "float16", 
                KernelName.c_str());

        if (!buildResult) {
            printf("Failed to build te custom op!\n");
            return FAILED;
        }

        te_bin_info.json_file_path = "./kernel_meta/" + KernelName + ".json";

        return SUCCESS;
    }

     /**
    * Register the op plugin
    * REGISTER_CUSTOM_OP:    Operator type name in om model, can be any but not duplicate with existence. case sensitive
    * FrameworkType:       Enum type, only support CAFFE
    * OriginOpType:        name of the operator type name in CAFFE
    * ParseParamsFn:      Op parameters parse function
    * InferShapeAndTypeFn: Set output description and datatype function
    * TEBinBuildFn:    Class name of op parser
    * ImplyType:           Instantiation type, TVM
    */
    REGISTER_CUSTOM_OP("JDEcoder_layer")
        .FrameworkType(CAFFE)
        .OriginOpType("JDEcoder")
        .ParseParamsFn(JDEcoderParseParams)
        .InferShapeAndTypeFn(JDEcoderInferShapeAndType)
        .TEBinBuildFn(JDEcoderBuildTeBin)
        .ImplyType(ImplyType::TVM);
}

